/*棋盘上 A 点有一个过河卒，需要走到目标 B 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 
C 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。
棋盘用坐标表示，A点(0,0)、B 点(n,m)，同样马的位置坐标是需要给出的。现在要求你计算出卒从
A点能够到达B点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。*/

/*分析：能到达点(x,y)的只有左侧的点(x-1,y)和上方的(x,y-1),故可通过迭代的思想列写计算式
f(x,y) = f(x-1,y) + f(x,y-1)。对于起点（0，0），这样计算会溢出，为简化代码使所有点向右下移动1个单位。*/

#include<stdio.h>
#include<math.h>
#define size 20//这是棋盘的最大尺寸

int main()
{
	int f[2], h[2];
	long long int axics[size + 2][size + 2] = { 0 };//加2防止溢出
	int x, y;
	scanf("%d%d%d%d", f, f + 1, h, h + 1);//读入卒的目标点和马的位置
	f[0] += 1; f[1] += 1;
	h[0] += 1; h[1] += 1;//为防止数组溢出，将数据+1
	axics[0][1] = 1;
	for (x = 1; x <= f[0]; x++)
		for (y = 1; y <= f[1]; y++)
			if (fabs((x - h[0]) * (y - h[1])) == 2||(x==h[0]&&y==h[1]))//判断马是否拦下卒
				continue;
			else
				axics[x][y] = axics[x - 1][y] + axics[x][y - 1];
	printf("%lld", axics[f[0]][f[1]]);
}
